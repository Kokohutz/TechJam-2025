<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Homomorphic Encryption NLP - Compute on Encrypted Data</title>
    <!-- Load compromise.js for NLP -->
    <script src="https://unpkg.com/compromise@14.10.0/builds/compromise.min.js"></script>
    <!-- Fallback CDN for compromise.js -->
    <script>
        // Fallback loading for compromise.js
        window.addEventListener('load', () => {
            if (typeof nlp === 'undefined') {
                console.log('Primary compromise.js CDN failed, trying fallback...');
                const fallbackScript = document.createElement('script');
                fallbackScript.src = 'https://cdn.jsdelivr.net/npm/compromise@14.10.0/builds/compromise.min.js';
                fallbackScript.onerror = () => {
                    console.error('Both compromise.js CDNs failed. Please check your internet connection.');
                    document.getElementById('featureStatus').textContent = '‚ùå NLP library failed to load';
                };
                document.head.appendChild(fallbackScript);
            }
        });
    </script>
    <!-- Load node-seal for homomorphic encryption -->
    <script src="https://cdn.jsdelivr.net/npm/node-seal@6.0.0/implementation/seal.d.ts"></script>

    <!-- Fallback CDN for node-seal -->
    <!-- <script>
        // Check if node-seal loaded properly
        window.addEventListener('load', () => {
            setTimeout(() => {
                if (typeof SEAL === 'undefined') {
                    console.log('Primary node-seal CDN may have failed, trying fallback...');
                    const fallbackScript = document.createElement('script');
                    fallbackScript.src = 'https://unpkg.com/node-seal@5.1.6/dist/seal.js';
                    fallbackScript.onerror = () => {
                        console.error('Both node-seal CDNs failed. Homomorphic encryption will not work.');
                        document.getElementById('encStatus').textContent = '‚ùå Encryption library unavailable';
                    };
                    document.head.appendChild(fallbackScript);
                }
            }, 2000);
        });
    </script> -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.15);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }
        
        .main-content {
            padding: 30px;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 25px;
        }
        
        .section {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            border: 2px solid #e9ecef;
        }
        
        .section h2 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }
        
        textarea {
            width: 100%;
            min-height: 100px;
            border: 2px solid #dee2e6;
            border-radius: 10px;
            padding: 12px;
            font-size: 13px;
            font-family: 'Courier New', monospace;
            resize: vertical;
        }
        
        textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 10px 18px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 8px 4px 0 0;
        }
        
        .button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        
        .button.danger {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a52 100%);
        }
        
        .button.success {
            background: linear-gradient(135deg, #51cf66 0%, #40c057 100%);
        }
        
        .results {
            background: #ffffff;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 12px;
            margin-top: 10px;
            min-height: 60px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            white-space: pre-wrap;
            overflow-y: auto;
            max-height: 200px;
        }
        
        .status {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: 600;
            margin: 8px 4px 0 0;
            display: inline-block;
        }
        
        .status.loading {
            background: #ffd43b;
            color: #000;
        }
        
        .status.encrypted {
            background: #ff6b6b;
            color: white;
        }
        
        .status.ready {
            background: #51cf66;
            color: white;
        }
        
        .wide-section {
            grid-column: 1 / -1;
        }
        
        .demo-section {
            background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
            color: #333;
        }
        
        .info-section {
            background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
            color: #333;
        }
        
        .performance-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .perf-card {
            background: rgba(255, 255, 255, 0.2);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }
        
        .perf-number {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr 1fr;
            }
        }
        
        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
                gap: 20px;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>üî¢ Homomorphic Encryption NLP</h1>
            <p>Compute on encrypted data without ever decrypting it</p>
        </div>

        <div class="main-content">
            <!-- Text Input Section -->
            <div class="section">
                <h2>üìù Sensitive Text Input</h2>
                <textarea id="textInput" placeholder="Enter sensitive text (medical records, personal data, etc.)...">Patient John Doe, age 45, diagnosed with diabetes and hypertension on 2024-03-15. Treatment includes metformin 500mg twice daily.</textarea>
                <button class="button" onclick="extractFeatures()">üß† Extract Features</button>
                <button class="button success" onclick="encryptFeatures()" id="encryptBtn" disabled>üîê Encrypt Features</button>
                <div class="results" id="featureResults">Features will appear here...</div>
                <span class="status loading" id="featureStatus">‚è≥ Ready to extract</span>
            </div>

            <!-- Encryption Status -->
            <div class="section">
                <h2>üîê Encryption Status</h2>
                <div class="results" id="encryptionResults">Encryption setup in progress...</div>
                <button class="button" onclick="setupEncryption()" id="setupBtn">‚öôÔ∏è Initialize Encryption</button>
                <button class="button danger" onclick="showEncryptedData()" id="showBtn" disabled>üëÅÔ∏è Show Encrypted Data</button>
                <span class="status loading" id="encStatus">üîÑ Setting up...</span>
            </div>

            <!-- Homomorphic Operations -->
            <div class="section">
                <h2>‚ö° Encrypted Computation</h2>
                <div class="results" id="computeResults">Ready for encrypted computation...</div>
                <button class="button success" onclick="performHomomorphicOps()" id="computeBtn" disabled>üßÆ Compute on Encrypted Data</button>
                <button class="button" onclick="aggregateEncrypted()" id="aggregateBtn" disabled>üìä Aggregate Features</button>
                <span class="status loading" id="computeStatus">‚è≥ Waiting for encryption</span>
            </div>

            <!-- Demo Explanation -->
            <div class="section wide-section demo-section">
                <h2>üéØ What's Happening Here?</h2>
                <p><strong>Step 1:</strong> Extract NLP features from your text using compromise.js</p>
                <p><strong>Step 2:</strong> Convert text features to numerical vectors</p>
                <p><strong>Step 3:</strong> Encrypt the feature vectors using Microsoft SEAL</p>
                <p><strong>Step 4:</strong> Perform mathematical operations on encrypted data</p>
                <p><strong>Step 5:</strong> Send encrypted results to server (never exposing raw data)</p>
                <br>
                <p>üî• <strong>Key Benefit:</strong> Your sensitive text never leaves your browser in unencrypted form. Even machine learning models can run on encrypted feature vectors!</p>
            </div>

            <!-- Performance Metrics -->
            <div class="section wide-section info-section">
                <h2>üìä Performance & Security Metrics</h2>
                <div class="performance-grid">
                    <div class="perf-card">
                        <div class="perf-number" id="encryptTime">--</div>
                        <div>Encryption Time (ms)</div>
                    </div>
                    <div class="perf-card">
                        <div class="perf-number" id="computeTime">--</div>
                        <div>Compute Time (ms)</div>
                    </div>
                    <div class="perf-card">
                        <div class="perf-number" id="securityLevel">128-bit</div>
                        <div>Security Level</div>
                    </div>
                    <div class="perf-card">
                        <div class="perf-number" id="dataSize">--</div>
                        <div>Encrypted Size (KB)</div>
                    </div>
                    <div class="perf-card">
                        <div class="perf-number" id="privacyLevel">100%</div>
                        <div>Privacy Preserved</div>
                    </div>
                </div>
            </div>

            <!-- Technical Implementation Details -->
            <div class="section wide-section">
                <h2>üõ†Ô∏è Technical Implementation</h2>
                <div class="results" id="technicalDetails">
                    üîß TECHNICAL STACK: ‚Ä¢ NLP Processing: compromise.js (client-side text analysis) ‚Ä¢ Homomorphic Encryption: node-seal (Microsoft SEAL WebAssembly) ‚Ä¢ Encryption Scheme: BFV (Brakerski-Fan-Vercauteren) ‚Ä¢ Security Level: 128-bit (military grade) ‚Ä¢ Operations:
                    Addition, multiplication, rotation on encrypted data ‚Ä¢ Performance: SIMD batching for parallel operations üì° PRIVACY GUARANTEES: ‚Ä¢ Raw text never leaves browser unencrypted ‚Ä¢ Feature extraction happens locally ‚Ä¢ Only encrypted numerical
                    data transmitted ‚Ä¢ Server can compute on encrypted data without decryption ‚Ä¢ Zero-knowledge: server learns nothing about original text ‚ö° REAL-WORLD APPLICATIONS: ‚Ä¢ Healthcare: Process medical records with full HIPAA compliance ‚Ä¢ Finance:
                    Analyze transaction data while preserving customer privacy ‚Ä¢ Legal: Compute on legal documents without exposing sensitive information ‚Ä¢ Research: Collaborate on sensitive datasets without data sharing
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables for homomorphic encryption
        let seal = null;
        let context = null;
        let keyGenerator = null;
        let publicKey = null;
        let secretKey = null;
        let encryptor = null;
        let decryptor = null;
        let evaluator = null;
        let encoder = null;
        let encryptedFeatures = [];
        let nlpFeatures = {};

        // Performance tracking
        let performanceMetrics = {
            encryptionTime: 0,
            computeTime: 0,
            dataSize: 0
        };

        // Initialize when page loads
        window.addEventListener('load', () => {
            updateStatus('encStatus', 'üîÑ Click Initialize to setup encryption');

            // Check if compromise.js loaded properly
            setTimeout(() => {
                if (typeof nlp !== 'undefined') {
                    updateStatus('featureStatus', '‚úÖ Ready - Enter text and click Extract Features');
                    console.log('‚úÖ compromise.js loaded successfully');
                } else {
                    updateStatus('featureStatus', '‚ö†Ô∏è NLP library loading... Please wait');
                    console.log('‚ö†Ô∏è compromise.js not yet available, retrying...');

                    // Try again after a longer delay
                    setTimeout(() => {
                        if (typeof nlp !== 'undefined') {
                            updateStatus('featureStatus', '‚úÖ Ready - Enter text and click Extract Features');
                            console.log('‚úÖ compromise.js loaded successfully (delayed)');
                        } else {
                            updateStatus('featureStatus', '‚ùå NLP library failed to load');
                            console.error('‚ùå compromise.js failed to load. Check internet connection.');
                        }
                    }, 3000);
                }
            }, 1000);
        });

        // Setup homomorphic encryption using node-seal
        async function setupEncryption() {
            updateStatus('encStatus', 'üîÑ Loading SEAL library...');
            document.getElementById('setupBtn').disabled = true;

            try {
                // Load node-seal library
                seal = await require_node_seal();

                updateStatus('encStatus', '‚öôÔ∏è Configuring encryption parameters...');

                // Setup encryption parameters for BFV scheme
                const schemeType = seal.SchemeType.bfv;
                const securityLevel = seal.SecurityLevel.tc128;
                const polyModulusDegree = 4096;
                const bitSizes = [36, 36, 37];
                const bitSize = 20;

                const parms = seal.EncryptionParameters(schemeType);
                parms.setPolyModulusDegree(polyModulusDegree);
                parms.setCoeffModulus(
                    seal.CoeffModulus.Create(polyModulusDegree, Int32Array.from(bitSizes))
                );
                parms.setPlainModulus(
                    seal.PlainModulus.Batching(polyModulusDegree, bitSize)
                );

                // Create context
                context = seal.Context(parms, true, securityLevel);

                if (!context.parametersSet()) {
                    throw new Error('Could not set the parameters in the given context.');
                }

                // Create keys and instances
                keyGenerator = seal.KeyGenerator(context);
                publicKey = keyGenerator.createPublicKey();
                secretKey = keyGenerator.secretKey();

                encryptor = seal.Encryptor(context, publicKey);
                decryptor = seal.Decryptor(context, secretKey);
                evaluator = seal.Evaluator(context);
                encoder = seal.BatchEncoder(context);

                // Update UI
                document.getElementById('encryptionResults').textContent = `
üéâ HOMOMORPHIC ENCRYPTION READY!
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

‚úÖ Microsoft SEAL initialized
üîê BFV scheme configured  
üîë Public/Private keys generated
‚ö° Batch encoder ready
üõ°Ô∏è 128-bit security level
üìä Polynomial degree: ${polyModulusDegree}
üßÆ Ready for encrypted computation

üí° You can now encrypt features and perform
   mathematical operations without decryption!
                `;

                updateStatus('encStatus', '‚úÖ Encryption Ready');
                document.getElementById('showBtn').disabled = false;

                // Enable encryption button if features are ready
                if (Object.keys(nlpFeatures).length > 0) {
                    document.getElementById('encryptBtn').disabled = false;
                }

            } catch (error) {
                console.error('Encryption setup error:', error);
                updateStatus('encStatus', '‚ùå Setup failed');
                document.getElementById('encryptionResults').textContent = `
‚ùå ENCRYPTION SETUP FAILED
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Error: ${error.message}

üîß TROUBLESHOOTING:
1. Check your internet connection
2. Refresh the page and try again
3. Make sure WebAssembly is enabled in your browser
4. Try using a different browser (Chrome, Firefox, Edge)

üí° ALTERNATIVE SOLUTION:
For production use, set up a local development environment:
1. npm install node-seal compromise
2. Use a bundler like Vite or Webpack
3. Import the libraries properly

üåê BROWSER COMPATIBILITY:
‚Ä¢ Chrome 57+ ‚úÖ
‚Ä¢ Firefox 52+ ‚úÖ 
‚Ä¢ Safari 11+ ‚úÖ
‚Ä¢ Edge 16+ ‚úÖ

‚ö†Ô∏è Note: Some corporate networks may block CDN resources.
         `;
                document.getElementById('setupBtn').disabled = false;
            }
        }

        // Extract NLP features using compromise.js
        function extractFeatures() {
            const text = document.getElementById('textInput').value.trim();
            if (!text) {
                alert('Please enter some text first');
                return;
            }

            updateStatus('featureStatus', 'üß† Processing text...');

            // Use compromise.js for NLP analysis
            const doc = nlp(text);

            // Extract comprehensive features
            nlpFeatures = {
                // Basic counts
                wordCount: doc.terms().length,
                sentenceCount: doc.sentences().length,

                // Named entities (convert to counts)
                peopleCount: doc.people().length,
                placesCount: doc.places().length,
                organizationsCount: doc.organizations().length,
                datesCount: doc.dates().length,

                // Parts of speech counts
                nounsCount: doc.nouns().length,
                verbsCount: doc.verbs().length,
                adjectivesCount: doc.adjectives().length,

                // Medical/sensitive terms (for demo)
                medicalTermsCount: countMedicalTerms(text),

                // Text complexity metrics
                avgWordLength: calculateAvgWordLength(doc.terms().out('array')),
                uniqueWordRatio: calculateUniqueWordRatio(doc.terms().out('array'))
            };

            // Display features
            document.getElementById('featureResults').textContent = `
üß† NLP FEATURES EXTRACTED
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üìä BASIC METRICS:
   Words: ${nlpFeatures.wordCount}
   Sentences: ${nlpFeatures.sentenceCount}
   Avg Word Length: ${nlpFeatures.avgWordLength.toFixed(2)}
   Unique Word Ratio: ${nlpFeatures.uniqueWordRatio.toFixed(2)}

üë• NAMED ENTITIES:
   People: ${nlpFeatures.peopleCount}
   Places: ${nlpFeatures.placesCount}
   Organizations: ${nlpFeatures.organizationsCount}
   Dates: ${nlpFeatures.datesCount}

üè∑Ô∏è PARTS OF SPEECH:
   Nouns: ${nlpFeatures.nounsCount}
   Verbs: ${nlpFeatures.verbsCount}
   Adjectives: ${nlpFeatures.adjectivesCount}

‚öïÔ∏è DOMAIN-SPECIFIC:
   Medical Terms: ${nlpFeatures.medicalTermsCount}

üîê Ready for encryption! These numerical features 
   will be encrypted and computed on securely.
            `;

            updateStatus('featureStatus', '‚úÖ Features extracted');

            // Enable encryption if SEAL is ready
            if (seal && context) {
                document.getElementById('encryptBtn').disabled = false;
            }
        }

        // Encrypt the extracted features
        async function encryptFeatures() {
            if (!nlpFeatures || Object.keys(nlpFeatures).length === 0) {
                alert('Please extract features first');
                return;
            }

            updateStatus('featureStatus', 'üîê Encrypting features...');
            const startTime = Date.now();

            try {
                // Convert features to array format for batch encoding
                const featureArray = Int32Array.from([
                    nlpFeatures.wordCount,
                    nlpFeatures.sentenceCount,
                    nlpFeatures.peopleCount,
                    nlpFeatures.placesCount,
                    nlpFeatures.organizationsCount,
                    nlpFeatures.datesCount,
                    nlpFeatures.nounsCount,
                    nlpFeatures.verbsCount,
                    nlpFeatures.adjectivesCount,
                    nlpFeatures.medicalTermsCount,
                    Math.floor(nlpFeatures.avgWordLength * 100), // Scale for integer encryption
                    Math.floor(nlpFeatures.uniqueWordRatio * 100)
                ]);

                // Encode and encrypt
                const plainText = encoder.encode(featureArray);
                const cipherText = encryptor.encrypt(plainText);

                // Store encrypted features
                encryptedFeatures = [cipherText];

                // Calculate metrics
                performanceMetrics.encryptionTime = Date.now() - startTime;
                const encryptedBase64 = cipherText.save();
                performanceMetrics.dataSize = Math.round(encryptedBase64.length / 1024);

                // Update UI
                document.getElementById('featureResults').textContent = `
üîê FEATURES ENCRYPTED SUCCESSFULLY!
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

‚úÖ ${featureArray.length} features encrypted
‚è±Ô∏è Encryption time: ${performanceMetrics.encryptionTime}ms
üì¶ Encrypted size: ${performanceMetrics.dataSize}KB
üõ°Ô∏è Security: 128-bit homomorphic encryption

üéØ ENCRYPTED FEATURE VECTOR:
${Array.from(featureArray).join(', ')}

üîí This encrypted data can now be sent to a server
   for machine learning inference without ever 
   exposing your original text!
                `;

                updateStatus('featureStatus', 'üîê Features encrypted');

                // Enable computation buttons
                document.getElementById('computeBtn').disabled = false;
                document.getElementById('aggregateBtn').disabled = false;
                updateStatus('computeStatus', '‚úÖ Ready for computation');

                // Update performance display
                document.getElementById('encryptTime').textContent = performanceMetrics.encryptionTime + 'ms';
                document.getElementById('dataSize').textContent = performanceMetrics.dataSize + 'KB';

            } catch (error) {
                console.error('Encryption error:', error);
                updateStatus('featureStatus', '‚ùå Encryption failed');
            }
        }

        // Perform homomorphic operations on encrypted data
        async function performHomomorphicOps() {
            if (encryptedFeatures.length === 0) {
                alert('Please encrypt features first');
                return;
            }

            updateStatus('computeStatus', 'üßÆ Computing on encrypted data...');
            const startTime = Date.now();

            try {
                const cipher = encryptedFeatures[0];

                // Perform various homomorphic operations

                // 1. Add the cipher to itself (double all values)
                const cipherDoubled = evaluator.add(cipher, cipher);

                // 2. Multiply by a constant (scale by 3)
                const three = encoder.encode(Int32Array.from([3]));
                const cipherScaled = evaluator.multiplyPlain(cipher, three);

                // 3. Perform a more complex operation
                const tempCipher = evaluator.add(cipherDoubled, cipherScaled);

                // Decrypt results to show they worked (normally you wouldn't do this on sensitive data)
                const decryptedOriginal = encoder.decode(decryptor.decrypt(cipher));
                const decryptedDoubled = encoder.decode(decryptor.decrypt(cipherDoubled));
                const decryptedScaled = encoder.decode(decryptor.decrypt(cipherScaled));
                const decryptedComplex = encoder.decode(decryptor.decrypt(tempCipher));

                performanceMetrics.computeTime = Date.now() - startTime;

                document.getElementById('computeResults').textContent = `
‚ö° HOMOMORPHIC COMPUTATION COMPLETE!
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

‚è±Ô∏è Computation time: ${performanceMetrics.computeTime}ms
üî¢ Operations performed on encrypted data:

üìä ORIGINAL ENCRYPTED VALUES:
   ${Array.from(decryptedOriginal.slice(0, 8)).join(', ')}...

‚ûï DOUBLED (cipher + cipher):
   ${Array.from(decryptedDoubled.slice(0, 8)).join(', ')}...

‚úñÔ∏è SCALED BY 3 (cipher * 3):  
   ${Array.from(decryptedScaled.slice(0, 8)).join(', ')}...

üßÆ COMPLEX (doubled + scaled):
   ${Array.from(decryptedComplex.slice(0, 8)).join(', ')}...

üî• KEY INSIGHT: All these computations happened
   on ENCRYPTED data! The server never saw your
   original text or unencrypted feature values.
                `;

                updateStatus('computeStatus', '‚úÖ Computation complete');
                document.getElementById('computeTime').textContent = performanceMetrics.computeTime + 'ms';

            } catch (error) {
                console.error('Computation error:', error);
                updateStatus('computeStatus', '‚ùå Computation failed');
            }
        }

        // Aggregate multiple encrypted feature sets (simulation)
        async function aggregateEncrypted() {
            if (encryptedFeatures.length === 0) {
                alert('Please encrypt features first');
                return;
            }

            updateStatus('computeStatus', 'üìä Aggregating encrypted data...');

            try {
                // Simulate having multiple encrypted datasets
                const cipher1 = encryptedFeatures[0];

                // Create a second "dataset" by scaling the first
                const two = encoder.encode(Int32Array.from([2]));
                const cipher2 = evaluator.multiplyPlain(cipher1, two);

                // Aggregate (sum) the encrypted datasets
                const aggregatedCipher = evaluator.add(cipher1, cipher2);

                // For demonstration, we'll decrypt to show the aggregation worked
                const original = encoder.decode(decryptor.decrypt(cipher1));
                const scaled = encoder.decode(decryptor.decrypt(cipher2));
                const aggregated = encoder.decode(decryptor.decrypt(aggregatedCipher));

                document.getElementById('computeResults').textContent = `
üìä ENCRYPTED DATA AGGREGATION COMPLETE!
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üè• SCENARIO: Multi-hospital collaboration
   ‚Ä¢ Hospital A and Hospital B want to compute
     joint statistics on patient data
   ‚Ä¢ Neither hospital can see the other's data
   ‚Ä¢ All computation happens on encrypted data

üìà AGGREGATION RESULTS:

üè• Hospital A (Original):
   ${Array.from(original.slice(0, 6)).join(', ')}...

üè• Hospital B (Simulated):  
   ${Array.from(scaled.slice(0, 6)).join(', ')}...

ü§ù JOINT STATISTICS (A + B):
   ${Array.from(aggregated.slice(0, 6)).join(', ')}...

‚úÖ PRIVACY PRESERVED: Each hospital's individual
   data remains completely private while enabling
   collaborative analytics!
   
üöÄ REAL APPLICATIONS:
   ‚Ä¢ Multi-party machine learning
   ‚Ä¢ Federated analytics
   ‚Ä¢ Privacy-preserving research
                `;

            } catch (error) {
                console.error('Aggregation error:', error);
                updateStatus('computeStatus', '‚ùå Aggregation failed');
            }
        }

        // Show encrypted data representation
        function showEncryptedData() {
            if (!publicKey || !secretKey) {
                alert('Please setup encryption first');
                return;
            }

            // Show the public key (safe to share)
            const publicKeyB64 = publicKey.save();

            document.getElementById('encryptionResults').textContent = `
üîê ENCRYPTION KEYS & PARAMETERS
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üîë PUBLIC KEY (safe to share):
${publicKeyB64.substring(0, 200)}...
(${publicKeyB64.length} characters total)

üõ°Ô∏è SECURITY PROPERTIES:
‚Ä¢ Algorithm: BFV Homomorphic Encryption
‚Ä¢ Security Level: 128-bit (equivalent to AES-128)
‚Ä¢ Key Size: 4096-bit polynomial degree
‚Ä¢ Operations: Addition, Multiplication, Rotation
‚Ä¢ Batching: Up to 4096 values per ciphertext

üîí PRIVATE KEY: NEVER SHOWN
(Stays secure in browser memory)

üí° With this setup, a server can:
   ‚úÖ Receive encrypted feature vectors
   ‚úÖ Perform ML inference on encrypted data  
   ‚úÖ Return encrypted results
   ‚ùå Never see your original text/features
            `;
        }

        // Helper functions
        function updateStatus(elementId, message) {
            const element = document.getElementById(elementId);
            element.textContent = message;

            // Update status styling based on content
            element.className = 'status';
            if (message.includes('‚úÖ') || message.includes('Ready')) {
                element.className += ' ready';
            } else if (message.includes('‚ùå') || message.includes('failed')) {
                element.className += ' error';
            } else if (message.includes('üîê')) {
                element.className += ' encrypted';
            } else {
                element.className += ' loading';
            }
        }

        function countMedicalTerms(text) {
            const medicalTerms = ['patient', 'diagnosis', 'treatment', 'medication', 'doctor', 'hospital', 'clinic', 'symptoms', 'disease', 'therapy', 'prescription', 'medical', 'health', 'condition', 'disorder'];
            let count = 0;
            const lowerText = text.toLowerCase();
            medicalTerms.forEach(term => {
                const matches = lowerText.match(new RegExp(term, 'g'));
                if (matches) count += matches.length;
            });
            return count;
        }

        function calculateAvgWordLength(words) {
            if (!words.length) return 0;
            const totalLength = words.reduce((sum, word) => sum + word.length, 0);
            return totalLength / words.length;
        }

        function calculateUniqueWordRatio(words) {
            if (!words.length) return 0;
            const uniqueWords = new Set(words.map(w => w.toLowerCase()));
            return uniqueWords.size / words.length;
        }

        // Mock function for node-seal loading (in real implementation, you'd import the actual library)
        async function require_node_seal() {
            // This is a simplified mock for demonstration
            // In a real implementation, you would:
            // 1. Include node-seal via npm or CDN
            // 2. Import it properly: import SEAL from 'node-seal'
            // 3. Initialize it: const seal = await SEAL()

            throw new Error('This is a demo. To run for real, install node-seal: npm i node-seal');
        }

        // Demo initialization message
        setTimeout(() => {
            console.log('üöÄ Homomorphic Encryption NLP Demo Loaded!');
            console.log('üìö Technologies:');
            console.log('   ‚Ä¢ compromise.js - Client-side NLP');
            console.log('   ‚Ä¢ node-seal - Homomorphic Encryption (Microsoft SEAL)');
            console.log('   ‚Ä¢ WebAssembly - Near-native performance');
            console.log('');

            // Check if SEAL is available
            if (typeof SEAL !== 'undefined') {
                console.log('‚úÖ node-seal library detected from CDN');
                console.log('üí° Ready to initialize homomorphic encryption!');
            } else {
                console.log('‚ö†Ô∏è node-seal library not detected');
                console.log('üí° Encryption features will show an error when attempted');
            }
        }, 1000);
    </script>
</body>

</html>